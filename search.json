[{"title":"快速幂法","url":"/2025/08/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B3%95/","content":"作者：Liew.Y\n先上代码后面解释\n#include &lt;cstdio&gt;int main(void) &#123;    // 快速幂法int base = 2;  // 底数2int power = 14;  // 指数nint result = 1;  // 结果    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 什么是快速幂法？\n其本质就是把幂不断降次。\n如： 2(10)12=4(10)62^{12}_{(10)} = 4^{6}_{(10)}2(10)12​=4(10)6​\n这个时候我们需要思考一个问题\n\n幂运算的本质是什么？\n\n\n其本质就是连续的乘法\n\n这个时候我们又要思考一个问题\n如何把降幂运算和计算机结合？\n思维链1. 首先计算机运算以及数据储存的形式是二进制2. 其次二进制每一位储存的形式是 2n3. 而 base×base=base24. 所以我们可以得到一个简单的思路5. 所有的 n(10) 都可以使用二进制形式 n(2) 来进行表示6. 对于 basepower=base2n+2n−1+⋯+207. 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base208. 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 首先计算机运算以及数据储存的形式是\\textbf{二进制}}\\\\[4pt]\n2. &amp;\\text{ 其次二进制每一位储存的形式是 }2^{n}\\\\[4pt]\n3. &amp;\\text{ 而 } \\text{base} \\times \\text{base}= \\text{base}^{2}\\\\[4pt]\n4. &amp;\\text{ 所以我们可以得到一个简单的思路}\\\\[4pt]\n5. &amp;\\text{ 所有的 }n_{(10)}\\text{ 都可以使用二进制形式 }n_{(2)}\\text{ 来进行表示}\\\\[4pt]\n6. &amp;\\text{ 对于 } \\text{base}^{\\text{power}} = \\text{base}^{2^{n}+2^{n-1}+\\dots+2^{0}}\\\\[4pt]\n7. &amp;\\text{ 最终我们可以得到 } \\text{base}^{\\text{power}}=\\text{base}^{2^{n}}\\cdot \\text{base}^{2^{n-1}}\\cdot \\dots \\cdot \\text{base}^{2^{0}}\\\\[4pt]\n8. &amp;\\text{ 我们还可以观察到 } \\text{base}^{2^{n}}=\\text{base}^{2^{n-1}}\\cdot \\text{base}^{2^{n-1}} = (\\text{base}^{2^{n-1}})^{2}\\\\[8pt]\n&amp;\\boxed{\\text{结果：以 }\\text{base}^{2}\\text{ 为基础不断降幂}}\n\\end{aligned}\n1.2.3.4.5.6.7.8.​思维链 首先计算机运算以及数据储存的形式是二进制 其次二进制每一位储存的形式是 2n 而 base×base=base2 所以我们可以得到一个简单的思路 所有的 n(10)​ 都可以使用二进制形式 n(2)​ 来进行表示 对于 basepower=base2n+2n−1+⋯+20 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base20 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂​​\n此时我们自然的想到\nif 存在2的某次方对应的位数为0 &#123;\t不应该相乘&#125; else &#123;\t相乘&#125;进入下一位\n此时我们产生了一个问题：\n如何确定是否要相乘？\n思维链1. 计算机以二进制存储数据。2. 降幂本质：base2k=(basek)2=basek⋅basek3. 二进制位不连续，如 1001(2)4. 仅需判断“当前位是否为 1”⇒真假5. 不关心原值是否被破坏。6. 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 0000 0001(2) 逐位取值\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 计算机以二进制存储数据。}\\\\[4pt]\n2. &amp;\\text{ 降幂本质：}\\quad \\text{base}^{2k}= (\\text{base}^{k})^{2} = \\text{base}^{k}\\cdot \\text{base}^{k} \\\\[4pt]\n3. &amp;\\text{ 二进制位不连续，如 }1001_{(2)}\\\\[4pt]\n4. &amp;\\text{ 仅需判断“当前位是否为 }1\\text{”} \\Rightarrow \\text{真假}\\\\[4pt]\n5. &amp;\\text{ 不关心原值是否被破坏。}\\\\[6pt]\n6. &amp;\\text{ 做法：}\\\\\n   &amp;\\quad\\text{power} \\&amp; 1  \\quad\\text{(取最低位)}\\\\\n   &amp;\\quad\\text{power} \\gg 1 \\quad\\text{(右移一位，丢弃已处理位)}\\\\[6pt]\n&amp;\\boxed{\\text{借助 }0000\\,0001_{(2)}\\text{ 逐位取值}}\n\\end{aligned}\n1.2.3.4.5.6.​思维链 计算机以二进制存储数据。 降幂本质：base2k=(basek)2=basek⋅basek 二进制位不连续，如 1001(2)​ 仅需判断“当前位是否为 1”⇒真假 不关心原值是否被破坏。 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 00000001(2)​ 逐位取值​​\n此时我们已经可以写出代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 3;int power = 5, result = 1;    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n进阶–递归法\nlong long fastPow(long long a, long long b) &#123;    if (b == 0) return 1;//截止条件    long long half = fastPow(a, b/2);//递归基    return (b % 2) ? half * half * a : half * half;//结果整合&#125;\n递归解析\n\n递归，递归，递归\n\nLiew.Y\n\n\n众所周知递归是很难理解的，所以针对递归我进行详细解释：其实是我不会\nStep1从“分-治-合”的角度分析分:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2治:计算子问题baseb=baseb/2⋅baseb/2合:整合子结果若 b 为奇数:baseb=baseb/2⋅baseb/2⋅base若 b 为偶数:baseb=baseb/2⋅baseb/2如何计算 baseb/2n利用 base0=1核心观察:baseb=(baseb/2)2\\begin{aligned}\n&amp;\\textbf{Step1} \\quad\\text{从“分-治-合”的角度分析}\\\\[6pt]\n\\textbf{分} &amp;: \\text{把指数 }b\\text{ 不断二分}\\\\\n&amp;\\quad\\text{快速幂的降幂基础：} \\mathbf{base^{b}} = (\\mathbf{base^{b/2}})^{2}\\\\[4pt]\n\\textbf{治} &amp;: \\text{计算子问题}\\\\\n&amp;\\quad\\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[4pt]\n\\textbf{合} &amp;: \\text{整合子结果}\\\\[4pt]\n\\text{若 b 为奇数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2} \\cdot \\text{base}}\\\\[4pt]\n\\text{若 b 为偶数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[6pt]\n\\text{如何计算 }&amp;\\mathbf{\\text{base}^{b/2^{n}}}\\\\[2pt]\n&amp;\\text{利用 } \\mathbf{\\text{base}^{0}=1}\\\\[6pt]\n\\text{核心观察}&amp;: \\mathbf{\\text{base}^{b} = \\bigl(\\text{base}^{b/2}\\bigr)^{2}}\n\\end{aligned}\n分治合若 b 为奇数若 b 为偶数如何计算 核心观察​Step1从“分-治-合”的角度分析:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2:计算子问题baseb=baseb/2⋅baseb/2:整合子结果:baseb=baseb/2⋅baseb/2⋅base:baseb=baseb/2⋅baseb/2baseb/2n利用 base0=1:baseb=(baseb/2)2​\n 补充部分\n我们由此次观察不仅可以得到可以通过\n\nN&amp;1\n\n的形式取得低位\n同时也可以自然的得到另一种方法\nN%2\n\nPROVE\n如果N_{(2)}=1001_{(2)}\n则 N_{(10)}=2{3}+2{0} 的形式，其中前项是偶数 =&gt; 余数=2^{0}\n\n 扩展\n 模下快速幂\n\n必备知识\n(a×b) mod c=((a mod c)×(b mod c)) mod c(a \\times b) \\bmod c = ((a \\bmod c) \\times (b \\bmod c)) \\bmod c(a×b)modc=((amodc)×(bmodc))modc\n这里我们或许认为很难以记忆\n其实确实不好理解  但是我们直接简记：层层求模\n\n 应用方法\n题目\n给定一个整数n求，2n2^{n}2n对于1007的模;\n\n思维链\n\n首先要求幂运算，我们可以想到快速幂法\n其次要求模，刚好结合我们的扩展\n现在开始拆分\n首先 result = result * base\n我们当然第一时刻想到的是直接对最终结果求mod\n但是显而易见，计算机的数据储存很可能不足\n所以我们采用扩展的公式\n对result和base分别求mod\n思考结果：更改开头代码对二者分别求mod\n\n\n完整代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 2;int power, result = 1;    scanf(&quot;%d&quot;, &amp;power);    while (power) &#123;        if (power &amp; 1) &#123;            result = (result * base) % 1007;        &#125;        base = (base * base) % 1007;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 注意\n虽然快速幂法相比于暴力算法更快\n但是需要记住快速幂法和暴力法一样都受制于内存的限制\n","categories":["ACM"],"tags":["算法"]},{"title":"资源整理_2","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86-2/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35\nGithub Profile: LiewYoung \n\n破山中贼易，破心中贼难。\n-王阳明\n\n 前情提要\n本次更新主抓可用性、及时性、高效性致力于提升大学生生活质量，将学生从枯燥无味的重复且无意义的劳作中解放出来。使得我们真正实现学习价值。同时结合大部分学生对电脑的掌握情况，不足一些常用软件。\n\n日常多嘴\nOOP也就是面向对象是一种思想，请不要把它和编程语言绑定OK吧，下学期学JAVA可别就会用JAVA写个类的继承就说自己面向对象了。\n\n\n一个线程要么被分离（detach），让系统自动回收资源；要么被连接（join），由主线程手动等待并回收资源。两者必须选其一，否则可能导致资源泄漏或未定义行为。\n\n 上期补全\n计算机教育课程系列\n计算机教育中缺失的一课 · the missing semester of your cs education\nAs we all know,高校本科阶段一般是教不了你什么真东西的。但是这些基础很重要：\n\n数据结构\n计算机组成原理\n操作系统\n计算机网络\n\n 正文\n 优质生活\n🎢工具学习类型的网站首页 - 廖雪峰的官方网站\nAs you can see! 一个类似编程扫盲的网站\n🧐OCS网课助手OCS网课助手\n你是否厌倦了枯燥且无聊的网课，面对100+的测试题你是否束手无策，没关系！现在你可以借助网课助手实现刷题刷课自由！！！Revolution！\n💻Optimizer卓越的Win11优化工具（这里F ** K Windows)Releases · hellzerg/optimizer\n🚀Nanazip快抛弃你那丑陋的WinRAR和像乌龟一样的自带解压缩吧Nanazip\n实际上我还是推荐有能力的去用7zip\n🙌Vmware免费好用的虚拟机软件，你用来干啥我不管，你不会下载请看VMware Workstation Pro 17官网下载安装教程_vmware17pro下载-CSDN博客\n\n再多嘴一次，你用Linux的话，为什么不用WSL呢？\n\n Github选集\n入门日报521xueweihan/HelloGitHub: :octocat: 分享 GitHub 上有趣、入门级的开源项目。Share interesting, entry-level open source projects on GitHub.\n制作自己的编程语言Make your own\n\n我多嘴一句，如果你连Makefile都不会写，gcc是什么都不知道，动态库和静态库都不知道基本区别（不需要你知道太深）你还是好好练练吧。\n\nCoding-interview-universityjwasham/coding-interview-university: A complete computer science study plan to become a software engineer.\n 卓越交流\nV2EX程序员的社区，纯净交流V2EX › 站点帮助首页请使用魔法访问\n AI小事记\n\n确实是没活了😶‍🌫️\n\n字节跳动旗下AI IDE（基于VScode）正式支持MCP功能。\nAI工具集合AI工具集官网 | 1000+ AI工具集合，国内外AI工具集导航大全\n看什么呢？学完了吗你！ 😂\n\nWin comes all day （赢麻了）\n\n","categories":["计算机基础"],"tags":["资源整理"]},{"title":"SDL入门","url":"/2025/08/10/SDL%E5%85%A5%E9%97%A8/","content":" 我的SDL3之旅（面向C语言初学者）：DAY1认识基本结构和创建窗口\n\n在上一篇文章中我们已经配置好了SDL3环境现在我们可以来写SDL3的代码了。\n如果没有配置请转到环境配置\n\n开发环境：Virtual Studio 2022\n 基本框架\n值得一提的是SDL3与SDL2不同，其舍弃了传统的main函数的入口模式，转而使用四个基本函数来处理程序的生命周期。下面我们来认识一下。\n 初始化函数\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])\n这个函数会在程序开始执行时运行一次，如果学过OOP的编程语言可以把这个类比成类的构造函数其只会执行一次。\n 参数解释\nvoid** appstate首先是一个二级指针，其指向的指针是一个结构体指针，其的作用主要是管理程序的相关状态。里面可以管理如**窗口（window）、渲染器（renderer）**一类的状态信息。\n int argc, char* argv[]这些是C/C++的传统命令行参数。\n 事件响应函数\nSDL_AppResult SDL_AppEvent(void* appstate,SDL_Event* event)\n这个函数会在有事件（如鼠标点击、键盘输入、QUIT退出）时调用。\n 参数解释\nvoid* appstate是一个指针传入APP的状态管理参数\nSDL_Event* event 负责传入APP当前响应的事件\n 帧渲染函数（主函数）\nSDL_AppResult SDL_AppIterate(void* appstate)\n这个函数会在每一帧运行一次，有点类似传统的while死循环方法。\n里面会处理你程序运行时的各种事件，当然也包括图形渲染。\n 后处理函数\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result)\n这个函数会在程序生命结束时调用，SDL会帮我们清理渲染和屏幕。同样的学过OOP编程语言的可以拿析构函数类比\n 参数解释\nSDL_AppResult result这个会传入程序的运行结构，如SUCCESS或者FALIURE\n 创建窗口\n 前置条件\n\n安装了SDL3环境\n具备基本的C/C++知识\n\n 知识补充\n\n屏幕坐标系\n\n\n屏幕坐标系是建立在屏幕上的二维坐标系，以像素为单位。屏幕的左上角为原点，水平方向为X轴，向右为正；垂直方向为Y轴，向下为正。\n\n\n计算机是如何渲染视频的\n\n\n我们看到的视频实际上有由一系列连续的图像形成的，我们把每一张图像叫做帧（fame）\n\n 书写代码\n首先定义宏来启用新式写法\n#define SDL_MAIN_USE_CALLBACKS 1\n现在引入头文件\n#include&lt;SDL3/SDL.h&gt;#include&lt;SDL3/SDL_main.h&gt;\n创建窗口也遵循传统的 ‘声明-初始-使用’ 的基本形式。\n现在定义两个全局变量\nstatic SDL_Window* window = NULL;static SDL_Renderer* renderer = NULL;\n现在我们可以开始写第一个函数了\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;&#125;\n首先我们需要调用\nSDL_SetAppMetadata( )函数来初始化程序的名称等。\n\nSDL_SetAppMetadata拥有三个参数（程序名称，版本信息，标识符）用于设置APP的元数据\n\n这里使用官方的Demo名称\nSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\n下面来初始化窗口和渲染器\nif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\n\n这里使用了SDL_Init()和SDL_CreateWindowAndRenderer()其实我们可以顾名思义一个是用来初始化权限的一个是用来创建窗口和渲染器的。\nSDL_GetError()会返回字符串内容是错误信息。\nSDL_Log()是SDL内置的日志打印函数。\n\n这里需要提一下SDL_Init()函数是使用|与运算符来申请多个权限的比如\nSDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO);\n下面是完整代码\n/*这个函数会在开始时执行一次*/SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;\t\t/*设置元数据*/\tSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\tif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面的函数很简单先略过\n/*这个函数会在有事件（如：鼠标、键盘输入）时调用*/SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) &#123;\tif (event-&gt;type == SDL_EVENT_QUIT) &#123;\t\treturn SDL_APP_SUCCESS; /*向操作系统传递程序成功执行*/\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面开始主函数SDL_AppResult SDL_AppIterate(void* appstate)\n/*下面设置渲染器*/SDL_AppResult SDL_AppIterate(void* appstate)&#123;\tSDL_SetRenderDrawColorFloat(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE_FLOAT);\t/*下面clear上一次渲染的内容*/\tSDL_RenderClear(renderer);\t/*现在把新的渲染器放到屏幕上*/\tSDL_RenderPresent(renderer);\treturn SDL_APP_CONTINUE;&#125;\n现在解释一下SDL_SetRenderDrawColorFloat()函数其接受渲染器和颜色（RGB）来设置渲染器颜色。SDL_ALPHA_OPAQUE_FLOAT是一个官方宏，表示不透明且是浮点型的参数。\n最后结尾\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result) &#123;\t/*pass*/&#125;\n 写在后面\n Q&amp;A\n为什么第一个SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[])的appstate参数是二级指针？\n\n因为这个函数是初始化函数，其目的是为了储存开发创建的状态对象\n其他函数只会修改这个对象的内容而不是这个对象所以是一级指针\n\n为什么没有使用appstate参数？\n\n官方说法是appstate会更方便开发者管理，尤其对于大项目，但是我使用着十分麻烦，而且我们就只是创建一个窗口，所以没有使用。\n\n你说话好啰嗦啊？\n\n你真是个小天才（开玩笑）\n其实主要面向的是刚学完C语言（不严谨就是会一点）的想图形化的同学写的。\n\n 感受\n本人技术也不是很好，但还是想说两句。\n学习这个SDL3其实最好的教程已经放在官方的Demo里面了，所以剩下的就是啃接口文档了。\n如有不妥，敬请指教\n","categories":["第三方库"],"tags":["SDL3"]},{"title":"补码","url":"/2025/08/10/%E8%A1%A5%E7%A0%81/","content":"作者：Liew.Y\n\n\n对于正数，补码与原码相同。\n\n\n负数在计算机中是使用其补码来表示的\n\n\n对于负数，补码是将原码的符号位保持不变，数值位按位取反后加1\n\n\n原码：10000001补码：Step1：01111110 Step2：11111100 \n在计算机中，反码（One’s Complement） 是一种数值的二进制表示方法，常用于辅助补码的计算。它的规则相对简单，但存在一些局限性。以下是关于反码的详细说明：\n 一、反码的定义与计算规则\n 1. 正数的反码\n与原码相同，即 符号位为 0，数值位不变。\n示例：\n\n十进制数 +5（4 位）的原码和反码均为：0101。\n\n 2. 负数的反码\n符号位为 1，数值位按位取反（0 变 1，1 变 0）。\n示例：\n\n十进制数 -5（4 位）的原码为 1101，反码为 1010（符号位不变，数值位 101 → 010）。\n\n 二、反码的特点\n\n\n存在 “负零” 问题\n\n十进制 0 的反码有两种表示：\n\n+0 的反码：0000（4 位）。\n-0 的反码：1111（4 位）。\n\n\n这会导致逻辑判断混乱（例如 0000 和 1111 都表示 0），因此反码在实际计算机中很少直接使用，而是作为补码的中间步骤。\n\n\n\n取值范围\n\nn 位反码的取值范围为：\n-(2^&#123;n-1&#125;-1) ~ +(2^&#123;n-1&#125;-1)。\n示例（4 位）：\n\n最小值：1111（反码）→ 对应十进制 -7。\n最大值：0111（反码）→ 对应十进制 +7。\n\n\n\n\n\n","categories":["计算机基础"],"tags":["算法"]},{"title":"资源整理","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35（完成时间）\nGithub Profile: LiewYoung \n\n欢迎来到我的Github，目前只有一些简单的脚本项目。\n欢迎与我共同进步😶‍🌫️\n\n 编程相关\n🤷‍♂️IO WIKI OI Wiki - OI Wiki\n介绍：\n一个ACM算法比赛爱好者的集合网站\n🚀菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！\n介绍：\n一个编程学习网站\n 万恶PPT\n🫡第一PPTPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】\n介绍：\n这个网站或许不够出彩但一定好用\n👍优品PPTPPT人物素材_PPT人物插图_PPT人物图片 - 优品PPT\n介绍:\n经过我检验的PPT素材获取平台\n🐉字行天下字体天下-提供各类字体的免费下载和在线预览服务\n介绍：\n免费字体下载，装饰你的PPT\n AI工具\n\n这是我最喜欢的部分，哈哈。\n\n🚀KIMIKimi - 会推理解析，能深度思考的AI助手\n介绍：\n推荐的原因很简单，谁让他可以一键生成PPT呢\n💻TeraTrae - AI 原生 IDE\n介绍：\n基于AI构建的IDE，不过基础不牢可不要依赖\n🚀百度文心一言文心一言\n介绍：\n说到百度大家可能好感骤减，但不得不说自从文心一言完全免费之后百度是真香啊，毕竟国内唯一一个有代码执行器的AI\n 社区类\n💻Linux DoLINUX DO - 新的理想型社区\n介绍：\n伟大理想主义者的联盟，在这里只有温和的技术交流没有抖音中的阴阳怪气\n 工具类\n🎵音乐搜索音乐搜索器 - 多站合一音乐搜索,音乐在线试听\n介绍：\n作为一名资深本地音乐玩家，没有什么比找音乐资源更困难了\n🌍FreeMindFreeMind-Make your mind free\n介绍：\n开源免费的思维导图软件就是有点丑\n🔍ObsidianObsidian - Sharpen your thinking\n介绍：\n强大的双链接MarkDown笔记软件，唯一缺点就是云同步不过我就一台电脑要什么自行车\n➕GeGebraGeoGebra - the world’s favorite, free math tools used by over 100 million students and teachers\n介绍：\n免费强大、风靡全球的的数学工具\n","categories":["计算机基础"],"tags":["资源整理"]}]