[{"title":"SDL入门","url":"/2025/08/10/SDL%E5%85%A5%E9%97%A8/","content":" 我的SDL3之旅（面向C语言初学者）：DAY1认识基本结构和创建窗口\n\n在上一篇文章中我们已经配置好了SDL3环境现在我们可以来写SDL3的代码了。\n如果没有配置请转到环境配置\n\n开发环境：Virtual Studio 2022\n 基本框架\n值得一提的是SDL3与SDL2不同，其舍弃了传统的main函数的入口模式，转而使用四个基本函数来处理程序的生命周期。下面我们来认识一下。\n 初始化函数\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])\n这个函数会在程序开始执行时运行一次，如果学过OOP的编程语言可以把这个类比成类的构造函数其只会执行一次。\n 参数解释\nvoid** appstate首先是一个二级指针，其指向的指针是一个结构体指针，其的作用主要是管理程序的相关状态。里面可以管理如**窗口（window）、渲染器（renderer）**一类的状态信息。\n int argc, char* argv[]这些是C/C++的传统命令行参数。\n 事件响应函数\nSDL_AppResult SDL_AppEvent(void* appstate,SDL_Event* event)\n这个函数会在有事件（如鼠标点击、键盘输入、QUIT退出）时调用。\n 参数解释\nvoid* appstate是一个指针传入APP的状态管理参数\nSDL_Event* event 负责传入APP当前响应的事件\n 帧渲染函数（主函数）\nSDL_AppResult SDL_AppIterate(void* appstate)\n这个函数会在每一帧运行一次，有点类似传统的while死循环方法。\n里面会处理你程序运行时的各种事件，当然也包括图形渲染。\n 后处理函数\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result)\n这个函数会在程序生命结束时调用，SDL会帮我们清理渲染和屏幕。同样的学过OOP编程语言的可以拿析构函数类比\n 参数解释\nSDL_AppResult result这个会传入程序的运行结构，如SUCCESS或者FALIURE\n 创建窗口\n 前置条件\n\n安装了SDL3环境\n具备基本的C/C++知识\n\n 知识补充\n\n屏幕坐标系\n\n\n屏幕坐标系是建立在屏幕上的二维坐标系，以像素为单位。屏幕的左上角为原点，水平方向为X轴，向右为正；垂直方向为Y轴，向下为正。\n\n\n计算机是如何渲染视频的\n\n\n我们看到的视频实际上有由一系列连续的图像形成的，我们把每一张图像叫做帧（fame）\n\n 书写代码\n首先定义宏来启用新式写法\n#define SDL_MAIN_USE_CALLBACKS 1\n现在引入头文件\n#include&lt;SDL3/SDL.h&gt;#include&lt;SDL3/SDL_main.h&gt;\n创建窗口也遵循传统的 ‘声明-初始-使用’ 的基本形式。\n现在定义两个全局变量\nstatic SDL_Window* window = NULL;static SDL_Renderer* renderer = NULL;\n现在我们可以开始写第一个函数了\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;&#125;\n首先我们需要调用\nSDL_SetAppMetadata( )函数来初始化程序的名称等。\n\nSDL_SetAppMetadata拥有三个参数（程序名称，版本信息，标识符）用于设置APP的元数据\n\n这里使用官方的Demo名称\nSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\n下面来初始化窗口和渲染器\nif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\n\n这里使用了SDL_Init()和SDL_CreateWindowAndRenderer()其实我们可以顾名思义一个是用来初始化权限的一个是用来创建窗口和渲染器的。\nSDL_GetError()会返回字符串内容是错误信息。\nSDL_Log()是SDL内置的日志打印函数。\n\n这里需要提一下SDL_Init()函数是使用|与运算符来申请多个权限的比如\nSDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO);\n下面是完整代码\n/*这个函数会在开始时执行一次*/SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;\t\t/*设置元数据*/\tSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\tif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面的函数很简单先略过\n/*这个函数会在有事件（如：鼠标、键盘输入）时调用*/SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) &#123;\tif (event-&gt;type == SDL_EVENT_QUIT) &#123;\t\treturn SDL_APP_SUCCESS; /*向操作系统传递程序成功执行*/\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面开始主函数SDL_AppResult SDL_AppIterate(void* appstate)\n/*下面设置渲染器*/SDL_AppResult SDL_AppIterate(void* appstate)&#123;\tSDL_SetRenderDrawColorFloat(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE_FLOAT);\t/*下面clear上一次渲染的内容*/\tSDL_RenderClear(renderer);\t/*现在把新的渲染器放到屏幕上*/\tSDL_RenderPresent(renderer);\treturn SDL_APP_CONTINUE;&#125;\n现在解释一下SDL_SetRenderDrawColorFloat()函数其接受渲染器和颜色（RGB）来设置渲染器颜色。SDL_ALPHA_OPAQUE_FLOAT是一个官方宏，表示不透明且是浮点型的参数。\n最后结尾\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result) &#123;\t/*pass*/&#125;\n 写在后面\n Q&amp;A\n为什么第一个SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[])的appstate参数是二级指针？\n\n因为这个函数是初始化函数，其目的是为了储存开发创建的状态对象\n其他函数只会修改这个对象的内容而不是这个对象所以是一级指针\n\n为什么没有使用appstate参数？\n\n官方说法是appstate会更方便开发者管理，尤其对于大项目，但是我使用着十分麻烦，而且我们就只是创建一个窗口，所以没有使用。\n\n你说话好啰嗦啊？\n\n你真是个小天才（开玩笑）\n其实主要面向的是刚学完C语言（不严谨就是会一点）的想图形化的同学写的。\n\n 感受\n本人技术也不是很好，但还是想说两句。\n学习这个SDL3其实最好的教程已经放在官方的Demo里面了，所以剩下的就是啃接口文档了。\n如有不妥，敬请指教\n","categories":["第三方库"],"tags":["SDL3"]},{"title":"Kadane算法","url":"/2025/08/14/Kadane%E7%AE%97%E6%B3%95/","content":" 什么是Kadane算法\nKadane算法说人话就是用来解决子数组和的问题。什么是子数组？子数组就是说一个数组是原数组的子集且元素连续。\n Kadane算法的基本思想\n就是基于动态规划一种思想：基本过程如下（关于动态规划的内容请在博客内搜索）：就是说我们每次都应该选取当前情况下最优解。举个例子：\n\n对于数组[1,1,-3,-1,3]\n我们可以很容易的得到最大子数组是[3],和为3。\n但是如果数组不这么简单我们应该如何解决？\n借助Kadane算法我们可以使用如下方法：\n\n设置两个变量，cMax（当前最大值）、gMax（全局最大值）\n我们把他们都初始为nums[0]\n接着我们进行累加，比较当前值和cMax+当前值的关系，如果当前值大于cMax+当前值，我们就应该舍弃cMax，否则应该保留，也就是把当前的值作为新的数组的开始。（思考一下为什么）\n这样我们就通过一次遍历实现了找到和最大的子数组。\n\n\n现在我们来思考：为什么要在如果当前值大于cMax+当前值的情况下舍弃cMax？这是一个很简单但又不简单的问题，我会使用相对详细的思想来解释。我们可以先思考什么情况下我们应该放弃前面的值（假设之前和没有最大值）：这是十分容易的，我们会在小于零的时候舍弃，因为此时前面的数组对我们的值没有正向作用。这样我们理解了为什么。现在我们思考如何做？当一个负数+正数时我们应该舍弃值，这就是解释。\n现在我们来思考如何找到最大值，比较标准是什么？这自然是一个很简单的问题，我们只需要找到比前一个最值更大的和就可以找到最终最大值。所以我们需要进行比较，每次加和之后cMax和gMax就进行比较，如果最大就更改gMax，这样我们就解决了找到最大子数组和的问题。\n MORE那么如何找到下标范围呢？\n这是十分容易的，我们每次只需要储存最大和的Start和End下标，使用Temp来暂时储存不知道会不会是最大值的新的开始头下标。\n SHOW ME THE CODE\nlong long n = 0;        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;nums[i];        &#125;  \t\t/*定义全区最大值和当前最大值*/        long long global_max = nums[0];        long long current_max = nums[0];        long long start=0,end=0,temp = 0;        for(long long i = 1;i&lt;n;i++)&#123;            if(nums[i]&gt;nums[i]+current_max)&#123;                current_max = nums[i];                temp = i;            &#125;else&#123;                current_max = current_max + nums[i];            &#125;            if(current_max&gt;global_max)&#123;                global_max = current_max;                start = temp;                end = i;            &#125;        &#125;\n RECOMMEND推荐练习题\n推荐航电OJ：1003题\n","categories":["ACM"],"tags":["算法","动态规划"]},{"title":"补码","url":"/2025/08/10/%E8%A1%A5%E7%A0%81/","content":"作者：Liew.Y\n\n\n对于正数，补码与原码相同的。\n\n\n负数在计算机中是使用其补码来表示的\n\n\n对于负数，补码是将原码的符号位保持不变，数值位按位取反后加1\n\n\n原码：10000001补码：Step1：01111110 Step2：11111100 \n在计算机中，反码（One’s Complement） 是一种数值的二进制表示方法，常用于辅助补码的计算。它的规则相对简单，但存在一些局限性。以下是关于反码的详细说明：\n 一、反码的定义与计算规则\n 1. 正数的反码\n与原码相同，即 符号位为 0，数值位不变。\n示例：\n\n十进制数 +5（4 位）的原码和反码均为：0101。\n\n 2. 负数的反码\n符号位为 1，数值位按位取反（0 变 1，1 变 0）。\n示例：\n\n十进制数 -5（4 位）的原码为 1101，反码为 1010（符号位不变，数值位 101 → 010）。\n\n 二、反码的特点\n\n\n存在 “负零” 问题\n\n十进制 0 的反码有两种表示：\n\n+0 的反码：0000（4 位）。\n-0 的反码：1111（4 位）。\n\n\n这会导致逻辑判断混乱（例如 0000 和 1111 都表示 0），因此反码在实际计算机中很少直接使用，而是作为补码的中间步骤。\n\n\n\n取值范围\n\nn 位反码的取值范围为：\n-(2^&#123;n-1&#125;-1) ~ +(2^&#123;n-1&#125;-1)。\n示例（4 位）：\n\n最小值：1111（反码）→ 对应十进制 -7。\n最大值：0111（反码）→ 对应十进制 +7。\n\n\n\n\n\n","categories":["计算机基础"],"tags":["算法"]},{"title":"资源整理_2","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86-2/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35\nGithub Profile: LiewYoung \n\n破山中贼易，破心中贼难。\n-王阳明\n\n 前情提要\n本次更新主抓可用性、及时性、高效性致力于提升大学生生活质量，将学生从枯燥无味的重复且无意义的劳作中解放出来。使得我们真正实现学习价值。同时结合大部分学生对电脑的掌握情况，不足一些常用软件。\n\n日常多嘴\nOOP也就是面向对象是一种思想，请不要把它和编程语言绑定OK吧，下学期学JAVA可别就会用JAVA写个类的继承就说自己面向对象了。\n\n\n一个线程要么被分离（detach），让系统自动回收资源；要么被连接（join），由主线程手动等待并回收资源。两者必须选其一，否则可能导致资源泄漏或未定义行为。\n\n 上期补全\n计算机教育课程系列\n计算机教育中缺失的一课 · the missing semester of your cs education\nAs we all know,高校本科阶段一般是教不了你什么真东西的。但是这些基础很重要：\n\n数据结构\n计算机组成原理\n操作系统\n计算机网络\n\n 正文\n 优质生活\n🎢工具学习类型的网站首页 - 廖雪峰的官方网站\nAs you can see! 一个类似编程扫盲的网站\n🧐OCS网课助手OCS网课助手\n你是否厌倦了枯燥且无聊的网课，面对100+的测试题你是否束手无策，没关系！现在你可以借助网课助手实现刷题刷课自由！！！Revolution！\n💻Optimizer卓越的Win11优化工具（这里F ** K Windows)Releases · hellzerg/optimizer\n🚀Nanazip快抛弃你那丑陋的WinRAR和像乌龟一样的自带解压缩吧Nanazip\n实际上我还是推荐有能力的去用7zip\n🙌Vmware免费好用的虚拟机软件，你用来干啥我不管，你不会下载请看VMware Workstation Pro 17官网下载安装教程_vmware17pro下载-CSDN博客\n\n再多嘴一次，你用Linux的话，为什么不用WSL呢？\n\n Github选集\n入门日报521xueweihan/HelloGitHub: :octocat: 分享 GitHub 上有趣、入门级的开源项目。Share interesting, entry-level open source projects on GitHub.\n制作自己的编程语言Make your own\n\n我多嘴一句，如果你连Makefile都不会写，gcc是什么都不知道，动态库和静态库都不知道基本区别（不需要你知道太深）你还是好好练练吧。\n\nCoding-interview-universityjwasham/coding-interview-university: A complete computer science study plan to become a software engineer.\n 卓越交流\nV2EX程序员的社区，纯净交流V2EX › 站点帮助首页请使用魔法访问\n AI小事记\n\n确实是没活了😶‍🌫️\n\n字节跳动旗下AI IDE（基于VScode）正式支持MCP功能。\nAI工具集合AI工具集官网 | 1000+ AI工具集合，国内外AI工具集导航大全\n看什么呢？学完了吗你！ 😂\n\nWin comes all day （赢麻了）\n\n","categories":["计算机基础"],"tags":["资源整理"]},{"title":"快速幂法","url":"/2025/08/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B3%95/","content":"作者：Liew.Y\n先上代码后面解释\n#include &lt;cstdio&gt;int main(void) &#123;    // 快速幂法int base = 2;  // 底数2int power = 14;  // 指数nint result = 1;  // 结果    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 什么是快速幂法？\n其本质就是把幂不断降次。\n如： 2(10)12=4(10)62^{12}_{(10)} = 4^{6}_{(10)}2(10)12​=4(10)6​\n这个时候我们需要思考一个问题\n\n幂运算的本质是什么？\n\n\n其本质就是连续的乘法\n\n这个时候我们又要思考一个问题\n如何把降幂运算和计算机结合？\n思维链1. 首先计算机运算以及数据储存的形式是二进制2. 其次二进制每一位储存的形式是 2n3. 而 base×base=base24. 所以我们可以得到一个简单的思路5. 所有的 n(10) 都可以使用二进制形式 n(2) 来进行表示6. 对于 basepower=base2n+2n−1+⋯+207. 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base208. 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 首先计算机运算以及数据储存的形式是\\textbf{二进制}}\\\\[4pt]\n2. &amp;\\text{ 其次二进制每一位储存的形式是 }2^{n}\\\\[4pt]\n3. &amp;\\text{ 而 } \\text{base} \\times \\text{base}= \\text{base}^{2}\\\\[4pt]\n4. &amp;\\text{ 所以我们可以得到一个简单的思路}\\\\[4pt]\n5. &amp;\\text{ 所有的 }n_{(10)}\\text{ 都可以使用二进制形式 }n_{(2)}\\text{ 来进行表示}\\\\[4pt]\n6. &amp;\\text{ 对于 } \\text{base}^{\\text{power}} = \\text{base}^{2^{n}+2^{n-1}+\\dots+2^{0}}\\\\[4pt]\n7. &amp;\\text{ 最终我们可以得到 } \\text{base}^{\\text{power}}=\\text{base}^{2^{n}}\\cdot \\text{base}^{2^{n-1}}\\cdot \\dots \\cdot \\text{base}^{2^{0}}\\\\[4pt]\n8. &amp;\\text{ 我们还可以观察到 } \\text{base}^{2^{n}}=\\text{base}^{2^{n-1}}\\cdot \\text{base}^{2^{n-1}} = (\\text{base}^{2^{n-1}})^{2}\\\\[8pt]\n&amp;\\boxed{\\text{结果：以 }\\text{base}^{2}\\text{ 为基础不断降幂}}\n\\end{aligned}\n1.2.3.4.5.6.7.8.​思维链 首先计算机运算以及数据储存的形式是二进制 其次二进制每一位储存的形式是 2n 而 base×base=base2 所以我们可以得到一个简单的思路 所有的 n(10)​ 都可以使用二进制形式 n(2)​ 来进行表示 对于 basepower=base2n+2n−1+⋯+20 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base20 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂​​\n此时我们自然的想到\nif 存在2的某次方对应的位数为0 &#123;\t不应该相乘&#125; else &#123;\t相乘&#125;进入下一位\n此时我们产生了一个问题：\n如何确定是否要相乘？\n思维链1. 计算机以二进制存储数据。2. 降幂本质：base2k=(basek)2=basek⋅basek3. 二进制位不连续，如 1001(2)4. 仅需判断“当前位是否为 1”⇒真假5. 不关心原值是否被破坏。6. 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 0000 0001(2) 逐位取值\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 计算机以二进制存储数据。}\\\\[4pt]\n2. &amp;\\text{ 降幂本质：}\\quad \\text{base}^{2k}= (\\text{base}^{k})^{2} = \\text{base}^{k}\\cdot \\text{base}^{k} \\\\[4pt]\n3. &amp;\\text{ 二进制位不连续，如 }1001_{(2)}\\\\[4pt]\n4. &amp;\\text{ 仅需判断“当前位是否为 }1\\text{”} \\Rightarrow \\text{真假}\\\\[4pt]\n5. &amp;\\text{ 不关心原值是否被破坏。}\\\\[6pt]\n6. &amp;\\text{ 做法：}\\\\\n   &amp;\\quad\\text{power} \\&amp; 1  \\quad\\text{(取最低位)}\\\\\n   &amp;\\quad\\text{power} \\gg 1 \\quad\\text{(右移一位，丢弃已处理位)}\\\\[6pt]\n&amp;\\boxed{\\text{借助 }0000\\,0001_{(2)}\\text{ 逐位取值}}\n\\end{aligned}\n1.2.3.4.5.6.​思维链 计算机以二进制存储数据。 降幂本质：base2k=(basek)2=basek⋅basek 二进制位不连续，如 1001(2)​ 仅需判断“当前位是否为 1”⇒真假 不关心原值是否被破坏。 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 00000001(2)​ 逐位取值​​\n此时我们已经可以写出代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 3;int power = 5, result = 1;    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n进阶–递归法\nlong long fastPow(long long a, long long b) &#123;    if (b == 0) return 1;//截止条件    long long half = fastPow(a, b/2);//递归基    return (b % 2) ? half * half * a : half * half;//结果整合&#125;\n递归解析\n\n递归，递归，递归\n\nLiew.Y\n\n\n众所周知递归是很难理解的，所以针对递归我进行详细解释：其实是我不会\nStep1从“分-治-合”的角度分析分:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2治:计算子问题baseb=baseb/2⋅baseb/2合:整合子结果若 b 为奇数:baseb=baseb/2⋅baseb/2⋅base若 b 为偶数:baseb=baseb/2⋅baseb/2如何计算 baseb/2n利用 base0=1核心观察:baseb=(baseb/2)2\\begin{aligned}\n&amp;\\textbf{Step1} \\quad\\text{从“分-治-合”的角度分析}\\\\[6pt]\n\\textbf{分} &amp;: \\text{把指数 }b\\text{ 不断二分}\\\\\n&amp;\\quad\\text{快速幂的降幂基础：} \\mathbf{base^{b}} = (\\mathbf{base^{b/2}})^{2}\\\\[4pt]\n\\textbf{治} &amp;: \\text{计算子问题}\\\\\n&amp;\\quad\\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[4pt]\n\\textbf{合} &amp;: \\text{整合子结果}\\\\[4pt]\n\\text{若 b 为奇数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2} \\cdot \\text{base}}\\\\[4pt]\n\\text{若 b 为偶数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[6pt]\n\\text{如何计算 }&amp;\\mathbf{\\text{base}^{b/2^{n}}}\\\\[2pt]\n&amp;\\text{利用 } \\mathbf{\\text{base}^{0}=1}\\\\[6pt]\n\\text{核心观察}&amp;: \\mathbf{\\text{base}^{b} = \\bigl(\\text{base}^{b/2}\\bigr)^{2}}\n\\end{aligned}\n分治合若 b 为奇数若 b 为偶数如何计算 核心观察​Step1从“分-治-合”的角度分析:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2:计算子问题baseb=baseb/2⋅baseb/2:整合子结果:baseb=baseb/2⋅baseb/2⋅base:baseb=baseb/2⋅baseb/2baseb/2n利用 base0=1:baseb=(baseb/2)2​\n 补充部分\n我们由此次观察不仅可以得到可以通过\n\nN&amp;1\n\n的形式取得低位\n同时也可以自然的得到另一种方法\nN%2\n\nPROVE\n如果N_{(2)}=1001_{(2)}\n则 N_{(10)}=2{3}+2{0} 的形式，其中前项是偶数 =&gt; 余数=2^{0}\n\n 扩展\n 模下快速幂\n\n必备知识\n(a×b) mod c=((a mod c)×(b mod c)) mod c(a \\times b) \\bmod c = ((a \\bmod c) \\times (b \\bmod c)) \\bmod c(a×b)modc=((amodc)×(bmodc))modc\n这里我们或许认为很难以记忆\n其实确实不好理解  但是我们直接简记：层层求模\n\n 应用方法\n题目\n给定一个整数n求，2n2^{n}2n对于1007的模;\n\n思维链\n\n首先要求幂运算，我们可以想到快速幂法\n其次要求模，刚好结合我们的扩展\n现在开始拆分\n首先 result = result * base\n我们当然第一时刻想到的是直接对最终结果求mod\n但是显而易见，计算机的数据储存很可能不足\n所以我们采用扩展的公式\n对result和base分别求mod\n思考结果：更改开头代码对二者分别求mod\n\n\n完整代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 2;int power, result = 1;    scanf(&quot;%d&quot;, &amp;power);    while (power) &#123;        if (power &amp; 1) &#123;            result = (result * base) % 1007;        &#125;        base = (base * base) % 1007;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 注意\n虽然快速幂法相比于暴力算法更快\n但是需要记住快速幂法和暴力法一样都受制于内存的限制\n","categories":["ACM"],"tags":["算法"]},{"title":"读《隐藏的潜能》我得到了什么？","url":"/2025/08/14/%E8%AF%BB%E3%80%8A%E9%9A%90%E8%97%8F%E7%9A%84%E6%BD%9C%E8%83%BD%E3%80%8B%E6%88%91%E5%BE%97%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"作者：Liew.Y\n时间：2025-03-17\n 海绵的故事\n在开始我们的故事之前，先认识一下主角——海绵（sponge）。它看似不起眼，却是地球上最古老的多细胞生物之一，化石可追溯到5.5亿年前的寒武纪。科学家在湖北宜昌发现的螺旋网格海绵化石，揭示了它作为原始动物的开端。古希腊人早就知道它，亚里士多德曾在书中记录它的用途，而希腊的KALYMNOS岛更以捕捞海绵闻名。300年前，那里的潜水员抱着15公斤的石头下潜30米，赤手抓取海绵；到19世纪，潜水服的发明让他们潜入70米深处，找到更优质的种类。\n但海绵的故事远不止这些。它曾被误认为是植物，因为它不移动、不捕食，静静地附着在海底。直到1765年，科学家通过研究它的细胞结构，才确认它属于动物。海绵没有华丽的外表，却能通过水流过滤食物，甚至在极端环境下存活亿万年。它的适应力令人惊叹——而这，正是我们今天要探讨的重点。\n 潜能的冰山一角\n说到适应力，你有没有想过，那些被称作“天才”的人，成功的秘诀是什么？我们常把“天赋”（talent）当作答案。在英语里，“gift”既是天赋也是礼物，仿佛成功是上天赐予少数人的特权。可现实真是这样吗？\n中国有个神童叫“伤仲永”。一个天赋异禀的孩子，年少成名，却因缺乏后天培养，最终泯然众人。天赋固然重要，但没有坚持和方法，它不过是一块未雕的石头。而普通人呢？我们发挥的能力，往往只是自身潜能的冰山一角。\n海绵就是个活生生的例子。它没有腿脚，却能在海底扎根；没有猎食的本领，却能靠水流生存。这种“低调的强大”，不正是潜能的体现吗？天才的成功，靠的不仅是天赋，更是一种超乎常人的坚持——像海绵一样，面对恶劣环境不屈服。而我们普通人，之所以觉得自己“平凡”，或许只是因为还没挖掘出那隐藏的部分。\n 持续：潜能的钥匙\n如果问大部分人为什么没能成功，答案往往是“我不够专注”。于是有人拼命练专注力，甚至科学研究也说“专注可以习得”。可结果呢？有些人苦练几年，成绩上去了，却过不了多久又回到原点，竹篮打水一场空。\n问题出在哪？不是不够努力，而是忽略了专注背后的东西——内驱力（internal drive）。王阳明说“心即理”，意思是真正的天理来自内心。海绵能在亿万年里存活，不是因为它“专注”过滤水流，而是因为它有种与生俱来的生存本能。天才也是如此：爱迪生试了上千种材料才发明灯泡，靠的不是天赋，是不服输的驱动力。\n现代社会太浮躁，纸醉金迷、唯利是图，让人容易迷失本心。我们羡慕天才，却忘了他们的成功不是天上掉下来的，而是从潜能里一点点挖出来的。接下来，我们会聊聊如何找到属于你的那股力量。\n 抵抗力：进步的前提\n不论学习什么，这些东西都不是一蹴而就的，我们免不了失败，免不了笨手笨脚的阶段。就像我们学习骑自行车，我们终究是从一次次摔到后学会的而不是在逃避中得到的。从这件小事我们就可以知道，我们应该敢于面对失败。从阿里巴巴的马云到全球巨富马斯克，无不是在失败中进步，但可悲的是我们大部分人都缺失了这样的一种能力——抵抗力，所谓抵抗力简而言之就是面对挫折、他人言语的忍受程度。我们处在一个原子化的社会也是物质的社会，我们人与人的关系再也不像乡土文明那样紧密，“社恐”似乎成为了大部分人的标签，当你对一些“社恐重度患者”说要求他们尝试一些舞蹈、说唱。他们总会以“我社恐”为借口来推脱，这就是缺乏抵抗力的表现，羞于面对挫折。但这还是相对好的一类人，更严重的人是完全忽视挫折他们不愿从痛苦的回忆中学习，这使得这些人逐渐落后于时代，停滞不前。似乎抵抗力是一个很重要的东西，那如何增强呢？请跟随我一同探索.\n原则之法其一：抛弃完美主义\n完美主义的特征：总想全盘兼顾，眼里容不下瑕疵。完美主义的本质是想要创造心中的乌托邦，但现实是不完美的，再光滑的球也有凹槽，再平整的平面也有凸起，人无完人，完美主义者的特性比定使他们陷入&quot;完美黑洞”。哈佛研究显示，完美主义者拖延症发病率高40%这就是”完美黑洞的影响。\n原则之法其二：无赖心理\n说起无赖，大家总是一种厌恶的表情，毕竟谁也不想当无赖。但是无赖有一种心态特别适合我们学习，那就是无所谓心理，什么意思呢？就是对凡事都以一种“我与万物共舞&quot;的心态，这里当然不是让你轻视所有事件，而是让你选择性的对自己的错误报以这样的心态去面对，这样就可以以更为平和的心态去从错误中学习。\n最后我想说：适度的挫折依赖反而会使我们取得更大的进步。\n 鹰架：激发内心的激荡\n这个部分我不想写了。\n","categories":["读书笔记"]},{"title":"资源整理","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35（完成时间）\nGithub Profile: LiewYoung \n\n欢迎来到我的Github，目前只有一些简单的脚本项目。\n欢迎与我共同进步😶‍🌫️\n\n 编程相关\n🤷‍♂️IO WIKI OI Wiki - OI Wiki\n介绍：\n一个ACM算法比赛爱好者的集合网站\n🚀菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！\n介绍：\n一个编程学习网站\n 万恶PPT\n🫡第一PPTPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】\n介绍：\n这个网站或许不够出彩但一定好用\n👍优品PPTPPT人物素材_PPT人物插图_PPT人物图片 - 优品PPT\n介绍:\n经过我检验的PPT素材获取平台\n🐉字行天下字体天下-提供各类字体的免费下载和在线预览服务\n介绍：\n免费字体下载，装饰你的PPT\n AI工具\n\n这是我最喜欢的部分，哈哈。\n\n🚀KIMIKimi - 会推理解析，能深度思考的AI助手\n介绍：\n推荐的原因很简单，谁让他可以一键生成PPT呢\n💻TeraTrae - AI 原生 IDE\n介绍：\n基于AI构建的IDE，不过基础不牢可不要依赖\n🚀百度文心一言文心一言\n介绍：\n说到百度大家可能好感骤减，但不得不说自从文心一言完全免费之后百度是真香啊，毕竟国内唯一一个有代码执行器的AI\n 社区类\n💻Linux DoLINUX DO - 新的理想型社区\n介绍：\n伟大理想主义者的联盟，在这里只有温和的技术交流没有抖音中的阴阳怪气\n 工具类\n🎵音乐搜索音乐搜索器 - 多站合一音乐搜索,音乐在线试听\n介绍：\n作为一名资深本地音乐玩家，没有什么比找音乐资源更困难了\n🌍FreeMindFreeMind-Make your mind free\n介绍：\n开源免费的思维导图软件就是有点丑\n🔍ObsidianObsidian - Sharpen your thinking\n介绍：\n强大的双链接MarkDown笔记软件，唯一缺点就是云同步不过我就一台电脑要什么自行车\n➕GeGebraGeoGebra - the world’s favorite, free math tools used by over 100 million students and teachers\n介绍：\n免费强大、风靡全球的的数学工具\n","categories":["计算机基础"],"tags":["资源整理"]}]