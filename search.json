[{"title":"快速幂法","url":"/2025/08/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B3%95/","content":"作者：Liew.Y\n先上代码后面解释\n#include &lt;cstdio&gt;int main(void) &#123;    // 快速幂法int base = 2;  // 底数2int power = 14;  // 指数nint result = 1;  // 结果    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 什么是快速幂法？\n其本质就是把幂不断降次。\n如： 2(10)12=4(10)62^{12}_{(10)} = 4^{6}_{(10)}2(10)12​=4(10)6​\n这个时候我们需要思考一个问题\n\n幂运算的本质是什么？\n\n\n其本质就是连续的乘法\n\n这个时候我们又要思考一个问题\n如何把降幂运算和计算机结合？\n思维链1. 首先计算机运算以及数据储存的形式是二进制2. 其次二进制每一位储存的形式是 2n3. 而 base×base=base24. 所以我们可以得到一个简单的思路5. 所有的 n(10) 都可以使用二进制形式 n(2) 来进行表示6. 对于 basepower=base2n+2n−1+⋯+207. 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base208. 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 首先计算机运算以及数据储存的形式是\\textbf{二进制}}\\\\[4pt]\n2. &amp;\\text{ 其次二进制每一位储存的形式是 }2^{n}\\\\[4pt]\n3. &amp;\\text{ 而 } \\text{base} \\times \\text{base}= \\text{base}^{2}\\\\[4pt]\n4. &amp;\\text{ 所以我们可以得到一个简单的思路}\\\\[4pt]\n5. &amp;\\text{ 所有的 }n_{(10)}\\text{ 都可以使用二进制形式 }n_{(2)}\\text{ 来进行表示}\\\\[4pt]\n6. &amp;\\text{ 对于 } \\text{base}^{\\text{power}} = \\text{base}^{2^{n}+2^{n-1}+\\dots+2^{0}}\\\\[4pt]\n7. &amp;\\text{ 最终我们可以得到 } \\text{base}^{\\text{power}}=\\text{base}^{2^{n}}\\cdot \\text{base}^{2^{n-1}}\\cdot \\dots \\cdot \\text{base}^{2^{0}}\\\\[4pt]\n8. &amp;\\text{ 我们还可以观察到 } \\text{base}^{2^{n}}=\\text{base}^{2^{n-1}}\\cdot \\text{base}^{2^{n-1}} = (\\text{base}^{2^{n-1}})^{2}\\\\[8pt]\n&amp;\\boxed{\\text{结果：以 }\\text{base}^{2}\\text{ 为基础不断降幂}}\n\\end{aligned}\n1.2.3.4.5.6.7.8.​思维链 首先计算机运算以及数据储存的形式是二进制 其次二进制每一位储存的形式是 2n 而 base×base=base2 所以我们可以得到一个简单的思路 所有的 n(10)​ 都可以使用二进制形式 n(2)​ 来进行表示 对于 basepower=base2n+2n−1+⋯+20 最终我们可以得到 basepower=base2n⋅base2n−1⋅⋯⋅base20 我们还可以观察到 base2n=base2n−1⋅base2n−1=(base2n−1)2结果：以 base2 为基础不断降幂​​\n此时我们自然的想到\nif 存在2的某次方对应的位数为0 &#123;\t不应该相乘&#125; else &#123;\t相乘&#125;进入下一位\n此时我们产生了一个问题：\n如何确定是否要相乘？\n思维链1. 计算机以二进制存储数据。2. 降幂本质：base2k=(basek)2=basek⋅basek3. 二进制位不连续，如 1001(2)4. 仅需判断“当前位是否为 1”⇒真假5. 不关心原值是否被破坏。6. 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 0000 0001(2) 逐位取值\\begin{aligned}\n&amp;\\textbf{思维链}\\\\[4pt]\n1. &amp;\\text{ 计算机以二进制存储数据。}\\\\[4pt]\n2. &amp;\\text{ 降幂本质：}\\quad \\text{base}^{2k}= (\\text{base}^{k})^{2} = \\text{base}^{k}\\cdot \\text{base}^{k} \\\\[4pt]\n3. &amp;\\text{ 二进制位不连续，如 }1001_{(2)}\\\\[4pt]\n4. &amp;\\text{ 仅需判断“当前位是否为 }1\\text{”} \\Rightarrow \\text{真假}\\\\[4pt]\n5. &amp;\\text{ 不关心原值是否被破坏。}\\\\[6pt]\n6. &amp;\\text{ 做法：}\\\\\n   &amp;\\quad\\text{power} \\&amp; 1  \\quad\\text{(取最低位)}\\\\\n   &amp;\\quad\\text{power} \\gg 1 \\quad\\text{(右移一位，丢弃已处理位)}\\\\[6pt]\n&amp;\\boxed{\\text{借助 }0000\\,0001_{(2)}\\text{ 逐位取值}}\n\\end{aligned}\n1.2.3.4.5.6.​思维链 计算机以二进制存储数据。 降幂本质：base2k=(basek)2=basek⋅basek 二进制位不连续，如 1001(2)​ 仅需判断“当前位是否为 1”⇒真假 不关心原值是否被破坏。 做法：power&amp;1(取最低位)power≫1(右移一位，丢弃已处理位)借助 00000001(2)​ 逐位取值​​\n此时我们已经可以写出代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 3;int power = 5, result = 1;    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n进阶–递归法\nlong long fastPow(long long a, long long b) &#123;    if (b == 0) return 1;//截止条件    long long half = fastPow(a, b/2);//递归基    return (b % 2) ? half * half * a : half * half;//结果整合&#125;\n递归解析\n\n递归，递归，递归\n\nLiew.Y\n\n\n众所周知递归是很难理解的，所以针对递归我进行详细解释：其实是我不会\nStep1从“分-治-合”的角度分析分:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2治:计算子问题baseb=baseb/2⋅baseb/2合:整合子结果若 b 为奇数:baseb=baseb/2⋅baseb/2⋅base若 b 为偶数:baseb=baseb/2⋅baseb/2如何计算 baseb/2n利用 base0=1核心观察:baseb=(baseb/2)2\\begin{aligned}\n&amp;\\textbf{Step1} \\quad\\text{从“分-治-合”的角度分析}\\\\[6pt]\n\\textbf{分} &amp;: \\text{把指数 }b\\text{ 不断二分}\\\\\n&amp;\\quad\\text{快速幂的降幂基础：} \\mathbf{base^{b}} = (\\mathbf{base^{b/2}})^{2}\\\\[4pt]\n\\textbf{治} &amp;: \\text{计算子问题}\\\\\n&amp;\\quad\\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[4pt]\n\\textbf{合} &amp;: \\text{整合子结果}\\\\[4pt]\n\\text{若 b 为奇数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2} \\cdot \\text{base}}\\\\[4pt]\n\\text{若 b 为偶数}&amp;: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[6pt]\n\\text{如何计算 }&amp;\\mathbf{\\text{base}^{b/2^{n}}}\\\\[2pt]\n&amp;\\text{利用 } \\mathbf{\\text{base}^{0}=1}\\\\[6pt]\n\\text{核心观察}&amp;: \\mathbf{\\text{base}^{b} = \\bigl(\\text{base}^{b/2}\\bigr)^{2}}\n\\end{aligned}\n分治合若 b 为奇数若 b 为偶数如何计算 核心观察​Step1从“分-治-合”的角度分析:把指数 b 不断二分快速幂的降幂基础：baseb=(baseb/2)2:计算子问题baseb=baseb/2⋅baseb/2:整合子结果:baseb=baseb/2⋅baseb/2⋅base:baseb=baseb/2⋅baseb/2baseb/2n利用 base0=1:baseb=(baseb/2)2​\n 补充部分\n我们由此次观察不仅可以得到可以通过\n\nN&amp;1\n\n的形式取得低位\n同时也可以自然的得到另一种方法\nN%2\n\nPROVE\n如果N_{(2)}=1001_{(2)}\n则 N_{(10)}=2{3}+2{0} 的形式，其中前项是偶数 =&gt; 余数=2^{0}\n\n 扩展\n 模下快速幂\n\n必备知识\n(a×b) mod c=((a mod c)×(b mod c)) mod c(a \\times b) \\bmod c = ((a \\bmod c) \\times (b \\bmod c)) \\bmod c(a×b)modc=((amodc)×(bmodc))modc\n这里我们或许认为很难以记忆\n其实确实不好理解  但是我们直接简记：层层求模\n\n 应用方法\n题目\n给定一个整数n求，2n2^{n}2n对于1007的模;\n\n思维链\n\n首先要求幂运算，我们可以想到快速幂法\n其次要求模，刚好结合我们的扩展\n现在开始拆分\n首先 result = result * base\n我们当然第一时刻想到的是直接对最终结果求mod\n但是显而易见，计算机的数据储存很可能不足\n所以我们采用扩展的公式\n对result和base分别求mod\n思考结果：更改开头代码对二者分别求mod\n\n\n完整代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 2;int power, result = 1;    scanf(&quot;%d&quot;, &amp;power);    while (power) &#123;        if (power &amp; 1) &#123;            result = (result * base) % 1007;        &#125;        base = (base * base) % 1007;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n 注意\n虽然快速幂法相比于暴力算法更快\n但是需要记住快速幂法和暴力法一样都受制于内存的限制\n","categories":["ACM"],"tags":["算法"]},{"title":"补码","url":"/2025/08/10/%E8%A1%A5%E7%A0%81/","content":"作者：Liew.Y\n\n\n对于正数，补码与原码相同。\n\n\n负数在计算机中是使用其补码来表示的\n\n\n对于负数，补码是将原码的符号位保持不变，数值位按位取反后加1\n\n\n原码：10000001补码：Step1：01111110 Step2：11111100 \n在计算机中，反码（One’s Complement） 是一种数值的二进制表示方法，常用于辅助补码的计算。它的规则相对简单，但存在一些局限性。以下是关于反码的详细说明：\n 一、反码的定义与计算规则\n 1. 正数的反码\n与原码相同，即 符号位为 0，数值位不变。\n示例：\n\n十进制数 +5（4 位）的原码和反码均为：0101。\n\n 2. 负数的反码\n符号位为 1，数值位按位取反（0 变 1，1 变 0）。\n示例：\n\n十进制数 -5（4 位）的原码为 1101，反码为 1010（符号位不变，数值位 101 → 010）。\n\n 二、反码的特点\n\n\n存在 “负零” 问题\n\n十进制 0 的反码有两种表示：\n\n+0 的反码：0000（4 位）。\n-0 的反码：1111（4 位）。\n\n\n这会导致逻辑判断混乱（例如 0000 和 1111 都表示 0），因此反码在实际计算机中很少直接使用，而是作为补码的中间步骤。\n\n\n\n取值范围\n\nn 位反码的取值范围为：\n-(2^&#123;n-1&#125;-1) ~ +(2^&#123;n-1&#125;-1)。\n示例（4 位）：\n\n最小值：1111（反码）→ 对应十进制 -7。\n最大值：0111（反码）→ 对应十进制 +7。\n\n\n\n\n\n","categories":["计算机基础"],"tags":["算法"]},{"title":"资源整理","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35（完成时间）\nGithub Profile: LiewYoung \n\n欢迎来到我的Github，目前只有一些简单的脚本项目。\n欢迎与我共同进步😶‍🌫️\n\n 编程相关\n🤷‍♂️IO WIKI OI Wiki - OI Wiki\n介绍：\n一个ACM算法比赛爱好者的集合网站\n🚀菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！\n介绍：\n一个编程学习网站\n 万恶PPT\n🫡第一PPTPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】\n介绍：\n这个网站或许不够出彩但一定好用\n👍优品PPTPPT人物素材_PPT人物插图_PPT人物图片 - 优品PPT\n介绍:\n经过我检验的PPT素材获取平台\n🐉字行天下字体天下-提供各类字体的免费下载和在线预览服务\n介绍：\n免费字体下载，装饰你的PPT\n AI工具\n\n这是我最喜欢的部分，哈哈。\n\n🚀KIMIKimi - 会推理解析，能深度思考的AI助手\n介绍：\n推荐的原因很简单，谁让他可以一键生成PPT呢\n💻TeraTrae - AI 原生 IDE\n介绍：\n基于AI构建的IDE，不过基础不牢可不要依赖\n🚀百度文心一言文心一言\n介绍：\n说到百度大家可能好感骤减，但不得不说自从文心一言完全免费之后百度是真香啊，毕竟国内唯一一个有代码执行器的AI\n 社区类\n💻Linux DoLINUX DO - 新的理想型社区\n介绍：\n伟大理想主义者的联盟，在这里只有温和的技术交流没有抖音中的阴阳怪气\n 工具类\n🎵音乐搜索音乐搜索器 - 多站合一音乐搜索,音乐在线试听\n介绍：\n作为一名资深本地音乐玩家，没有什么比找音乐资源更困难了\n🌍FreeMindFreeMind-Make your mind free\n介绍：\n开源免费的思维导图软件就是有点丑\n🔍ObsidianObsidian - Sharpen your thinking\n介绍：\n强大的双链接MarkDown笔记软件，唯一缺点就是云同步不过我就一台电脑要什么自行车\n➕GeGebraGeoGebra - the world’s favorite, free math tools used by over 100 million students and teachers\n介绍：\n免费强大、风靡全球的的数学工具\n","categories":["计算机基础"]}]